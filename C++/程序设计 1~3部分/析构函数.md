[[结构体vector]]

析构函数是在对象生命周期结束时被调用的特殊成员函数。它的主要目的是执行对象的清理工作，释放分配的资源，关闭文件，或执行其他必要的清理操作。析构函数的调用时机取决于对象的生命周期
在以下情况下，析构函数会被调用：

1. **对象离开其作用域**：
- 对于局部对象，当其定义的作用域结束时，会自动调用析构函数。这包括函数内部的局部对象，以及在语句块中定义的对象
```cpp
void someFunction() {
    MyClass obj;  // 构造函数被调用
    // 在这里使用 obj
} // 作用域结束，析构函数被调用
```

2. **动态分配的对象被删除**：
- 如果对象是通过 `new` 运算符动态分配的，那么在调用 `delete` 时会触发析构函数的调用
```cpp
MyClass* obj = new MyClass;  // 构造函数被调用
// 在这里使用 obj
delete obj;  // 析构函数被调用
```

3. **标准库容器的元素被销毁**：
- 在标准库容器（如 `std::vector`、`std::list`）中存储的对象，在容器被销毁或元素被移除时，会调用元素的析构函数
```cpp
std::vector<MyClass> vec;
vec.push_back(MyClass());  // 构造函数被调用
// 在这里使用 vec
// 当 vec 被销毁时，存储在其中的 MyClass 对象的析构函数被调用
```

4. **全局对象在程序结束时被销毁**：
- 对于全局对象，其析构函数会在程序结束时被调用
```cpp
MyClass globalObj;  // 全局对象，构造函数被调用
// 在这里使用 globalObj
// 当程序结束时，globalObj 的析构函数被调用
```

5. **静态对象在程序结束时被销毁**：
- 对于静态对象，其析构函数也会在程序结束时被调用
```cpp
static MyClass staticObj;  // 静态对象，构造函数被调用
// 在这里使用 staticObj
// 当程序结束时，staticObj 的析构函数被调用
```

总的来说，析构函数的调用时机是与对象的生命周期相关的，主要在对象不再需要时执行清理工作。在现代C++中，使用智能指针、RAII（资源获取即初始化）等技术可以帮助自动管理对象的生命周期，减少手动调用 `new` 和 `delete` 的需求，从而减轻了手动管理资源的负担

---
  
如果你没有为类编写析构函数，C++ 编译器会为你生成一个默认析构函数。这个默认析构函数会自动调用类成员的析构函数（如果有的话），并释放对象占用的内存。默认析构函数的行为是递归地销毁类的成员，直至销毁完整个对象。

需要注意的是，默认生成的析构函数是针对类的成员进行逐个销毁，并且对于动态分配的内存，会调用适当的 `delete` 操作符。但是对于其他资源（例如文件句柄、网络连接等），编译器生成的默认析构函数并不能提供适当的资源清理。

如果你的类中包含了需要特殊处理的资源（如动态分配的内存），而你又没有提供自定义的析构函数，可能会导致资源泄漏或其他问题。

以下是一个简单的例子，演示了默认生成的析构函数的行为：

```cpp
#include <iostream>

class MyClass {
public:
    MyClass() {
        std::cout << "Constructor" << std::endl;
        data = new int[10];
    }

    // 没有显式定义析构函数

private:
    int* data;
};

int main() {
    {
        MyClass obj; // 创建对象，调用构造函数
    } // 对象超出作用域，调用默认生成的析构函数

    return 0;
}
```

